[{"path":"https://richfitz.github.io/storr/articles/external.html","id":"memoisation","dir":"Articles","previous_headings":"","what":"Memoisation","title":"external","text":"external storr can support form memoisation, though might simpler implement directly (see ). Suppose expensive function f(, b) set parameters run function , parameter set (row) associated id: hook simply looks parameters arranges run : first time result retrieved message printed (function evaluated) second time, result retrieved storr: idea can generalised storing parameters functions storr lose dependency global variables: Memoisation style memoise package possible implement, provided package. Implementation straightforward work driver: ’s function print evaluated Create memoised function first time argument seen, f() run, printing message Subsequent times looked storr: Storr takes twice long memoise (memoise direct key->value mapping rather going hashed values thing ever touches cache). However, overhead approximately half one call message() ’s bad.","code":"f <- function(a, b) {   message(sprintf(\"Computing f(%.3f, %.3f)\", a, b))   ## ...expensive computation here...   list(a, b) } pars <- data.frame(id = as.character(1:10), a = runif(10), b = runif(10),                    stringsAsFactors = FALSE) hook <- function(key, namespace) {   p <- pars[match(key, pars$id), -1]   f(p$a, p$b) }  st <- storr::storr_external(storr::driver_environment(), hook) x <- st$get(\"1\") ## Computing f(0.081, 0.875) identical(st$get(\"1\"), x) ## [1] TRUE st <- storr::storr_environment() st$set(\"experiment1\", pars, namespace = \"parameters\") st$set(\"experiment1\", f, namespace = \"functions\")  hook2 <- function(key, namespace) {   f <- st$get(namespace, namespace = \"functions\")   pars <- st$get(namespace, namespace = \"parameters\")   p <- pars[match(key, pars$id), -1]   f(p$a, p$b) }  st_use <- storr::storr_external(st$driver, hook2)  x1 <- st_use$get(\"1\", \"experiment1\") ## Computing f(0.081, 0.875) x2 <- st_use$get(\"1\", \"experiment1\") memoise <- function(f, driver = storr::driver_environment()) {   force(f)   st <- storr::storr(driver)   function(...) {     ## NOTE: also digesting the inputs as a key here (in addition to     ## storr's usual digesting of values)     key <- digest::digest(list(...))     tryCatch(       st$get(key),       KeyError = function(e) {         ans <- f(...)         st$set(key, ans)         ans       })   } } f <- function(x) {   message(\"computing...\")   x * 2 } g <- memoise(f) g(1) ## computing... ## [1] 2 g(1) ## [1] 2"},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"key-value-store","dir":"Articles","previous_headings":"","what":"Key-value store","title":"storr","text":"main way interacting storr object get/set/del getting, setting deleting data stored key. store data: get data back storr? , much faster, test existence particular key: delete key: ’s gone! though actual data still stored database: hash object computed using digest package, can done using hash_object method storr. object can retrieved directly given hash: similarly, can test see object present database using hash: though now keys pointing data subject garbage collection:","code":"st$set(\"mykey\", mtcars) head(st$get(\"mykey\")) ##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb ## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 ## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 ## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 ## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 ## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 ## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 st$list() ## [1] \"mykey\" st$exists(\"mykey\") ## [1] TRUE st$exists(\"another_key\") ## [1] FALSE st$del(\"mykey\") st$list() ## character(0) h <- st$list_hashes() h ## [1] \"a63c70e73b58d0823ab3bcbd3b543d6f\" st$hash_object(mtcars) ## [1] \"a63c70e73b58d0823ab3bcbd3b543d6f\" head(st$get_value(h)) ##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb ## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 ## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 ## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 ## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 ## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 ## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 st$exists_object(h) ## [1] TRUE del <- st$gc() del ## [1] \"a63c70e73b58d0823ab3bcbd3b543d6f\" st$list_hashes() ## character(0)"},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"namespaces","dir":"Articles","previous_headings":"","what":"Namespaces","title":"storr","text":"point everything stored great big bucket may become unstructured. help storr implements simple “namespace” system may help provide structure. single layer hierarchy keys; every key belongs namespace. default namespace “objects” can configured storr created. list_namespaces() method lists known namespaces create new namespace, simply assign object : list() method lists contents single namespace get object, must use correct namespace:","code":"st$default_namespace ## [1] \"objects\" st$list_namespaces() ## [1] \"objects\" st$set(\"a\", runif(5), namespace = \"other_things\") st$list_namespaces() ## [1] \"objects\"      \"other_things\" st$list() ## character(0) st$list(\"other_things\") ## [1] \"a\" st$get(\"a\") ## Error: key 'a' ('objects') not found st$get(\"a\", \"other_things\") ## [1] 0.080750138 0.834333037 0.600760886 0.157208442 0.007399441"},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"bulk-getset","dir":"Articles","previous_headings":"","what":"Bulk get/set","title":"storr","text":"many values get set, databases much efficient get set bulk; particularly case high-latency databases (e.g., anything network connection, especially internet connection). help , storr implements mget mset methods allow multiple values retrieved set. mset function allows multiple keys (/multiple namespaces) multiple data elements. data must length() number keys set. mget function fetches zero elements. mget always returns list number elements number keys mset mget, key namespace can vectors; either non-scalar, must length logic fairly predictable","code":"st$mset(c(\"a\", \"b\", \"c\"), list(1, 2, 3)) st$get(\"a\") ## [1] 1 st$mget(c(\"a\", \"b\", \"c\")) ## [[1]] ## [1] 1 ##  ## [[2]] ## [1] 2 ##  ## [[3]] ## [1] 3 st$mget(\"a\") ## [[1]] ## [1] 1 st$mget(character(0)) ## list() st$mset(\"x\", list(\"a\", \"b\"), namespace = c(\"ns1\", \"ns2\")) st$mget(\"x\", c(\"ns1\", \"ns2\")) ## [[1]] ## [1] \"a\" ##  ## [[2]] ## [1] \"b\" st$mget(c(\"a\", \"b\", \"x\"), c(\"objects\", \"objects\", \"ns1\")) ## [[1]] ## [1] 1 ##  ## [[2]] ## [1] 2 ##  ## [[3]] ## [1] \"a\""},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"import-export","dir":"Articles","previous_headings":"","what":"Import / export","title":"storr","text":"Objects can imported exported storr: Import list, environment another storr Export environment (another storr)","code":"st$import(list(a = 1, b = 2)) st$list() ## [1] \"a\" \"b\" \"c\" st$get(\"a\") ## [1] 1 e <- st$export(new.env(parent = emptyenv())) ls(e) ## [1] \"a\" \"b\" \"c\" e$a ## [1] 1 st_copy <- st$export(storr_environment()) st_copy$list() ## [1] \"a\" \"b\" \"c\" st$get(\"a\") ## [1] 1 st2 <- storr::storr(driver = storr::driver_rds(tempfile(\"storr_\"))) st2$list() ## character(0) st2$import(st) st2$list() ## [1] \"a\" \"b\" \"c\""},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"supported-backends","dir":"Articles","previous_headings":"","what":"Supported backends","title":"storr","text":"environments (driver_environment) - mostly debugging transient storage, far fastest. disk rds (driver_rds) - zero dependencies, quite fast, suffer high concurrency file locking. DBI (driver_dbi) - uses (abuses?) relational database store data. fastest interface allows interprocess key/value stores relational database supported. databases supported DBI supported (least SQLite, MySQL Postgres). Redis (driver_redis) - uses redux store data Redis (http://redis.io) database. speed rds (faster write, slower read present), can allow multiple R processes share set objects. rlite (driver_rlite) - stores data rlite database using rrlite. quite quick, stalled general release rrlite support windows. -development package thor provides alternative -disk storr can handle multiple processes single machine.","code":""},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"implementation-details","dir":"Articles","previous_headings":"","what":"Implementation details","title":"storr","text":"storr includes useful features common drivers.","code":""},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"content-addressable-lookup","dir":"Articles","previous_headings":"Implementation details","what":"Content addressable lookup","title":"storr","text":"thing stored key hash object. driver different way, rds driver stores small text files list hash . : one big pool hash / value pairs: rds driver stored like :","code":"dir(file.path(path, \"keys\", \"objects\")) ## [1] \"a\" \"b\" \"c\" readLines(file.path(path, \"keys\", \"objects\", \"a\")) ## [1] \"6717f2823d3202449301145073ab8719\" st$get_hash(\"a\") ## [1] \"6717f2823d3202449301145073ab8719\" st$list_hashes() ## [1] \"07791acf30327c525aa5a1525f9a6a27\" \"127a2ec00989b9f7faf671ed470be7f8\" ## [3] \"6717f2823d3202449301145073ab8719\" \"db8e490a925a60e62212cefc7674ca02\" ## [5] \"ddf100612805359cd81fdc5ce3b9fbba\" \"e5b57f323c7b3719bbaaf9f96b260d39\" dir(file.path(path, \"data\")) ## [1] \"07791acf30327c525aa5a1525f9a6a27.rds\" ## [2] \"127a2ec00989b9f7faf671ed470be7f8.rds\" ## [3] \"6717f2823d3202449301145073ab8719.rds\" ## [4] \"db8e490a925a60e62212cefc7674ca02.rds\" ## [5] \"ddf100612805359cd81fdc5ce3b9fbba.rds\" ## [6] \"e5b57f323c7b3719bbaaf9f96b260d39.rds\""},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"environment-based-caching","dir":"Articles","previous_headings":"Implementation details","what":"Environment-based caching","title":"storr","text":"Every time data passes across get set method, storr stores data environment within storr object. store content hash, ’s always sync saved disk. means look-process goes like : Ask key, get returned hash content Check caching environment hash return present present, read content disk/db/wherever driver stores save caching environment looking data environment likely orders magnitude faster reading disks databases, means commonly accessed data accessed similar speed native R objects, still immediately reflecting changes content (mean hash changes) demonstrate: caching environment; currently empty Set key data: environment now includes object name hash contents: Extract object environment hash look value stored key mykey, first step check key/hash map; returns key (step involve reading disk) calls $get_value extract value associated hash - first thing function try locate hash environment, otherwise reads data wherever driver stores . speed going fairly context dependent, 5-10x seems pretty good case (overhead simply longer code path call driver). big bits data slow network connections difference much pronounced.","code":"st <- storr::storr(driver = storr::driver_rds(tempfile(\"storr_\"))) ls(st$envir) ## character(0) set.seed(2) st$set(\"mykey\", runif(100)) ls(st$envir) ## [1] \"3386dd0f1a8a3fe4ed209420ea23c8eb\" st$hash_object(st$envir[[ls(st$envir)]]) ## [1] \"3386dd0f1a8a3fe4ed209420ea23c8eb\" st$get_hash(\"mykey\") ## [1] \"3386dd0f1a8a3fe4ed209420ea23c8eb\" st$get_value ## function (hash, use_cache = TRUE)  ## { ##     envir <- self$envir ##     if (use_cache && exists0(hash, envir)) { ##         value <- envir[[hash]] ##     } ##     else { ##         if (self$traits$throw_missing) { ##             value <- tryCatch(self$driver$get_object(hash), error = function(e) stop(HashError(hash))) ##         } ##         else { ##             if (!self$driver$exists_object(hash)) { ##                 stop(HashError(hash)) ##             } ##             value <- self$driver$get_object(hash) ##         } ##         if (use_cache) { ##             envir[[hash]] <- value ##         } ##     } ##     value ## } ## <environment: 0x55c4cc0eaa30> hash <- st$get_hash(\"mykey\") if (requireNamespace(\"rbenchmark\")) {   rbenchmark::benchmark(st$get_value(hash, use_cache = TRUE),                         st$get_value(hash, use_cache = FALSE),                         replications = 1000, order = NULL)[1:4] } ## Loading required namespace: rbenchmark ##                                    test replications elapsed relative ## 1  st$get_value(hash, use_cache = TRUE)         1000   0.010      1.0 ## 2 st$get_value(hash, use_cache = FALSE)         1000   0.063      6.3"},{"path":"https://richfitz.github.io/storr/articles/storr.html","id":"classed-exceptions","dir":"Articles","previous_headings":"Implementation details","what":"Classed exceptions","title":"storr","text":"storr uses R’s exception handling system errors inspired Python make easy program tryCatch. key database, storr return KeyError (NULL storing NULL value perfectly reasonable thing ). want return NULL key requested present, use tryCatch way: See ?tryCatch details. idea key lookup errors class KeyError caught run given function (argument e actual error object). errors caught still throw. HashErrors rarer, happen (might occur driver supports expiry objects). can simulate setting hash deleting : HashError triggered. KeyError objects include key namespace elements, HashError objects include hash element. inherit c(\"error\", \"condition\"). Finally, using external storr (see ?driver_external) storr throw KeyErrorExternal fetch_hook function errors trying retrieve external resource.","code":"tryCatch(st$get(\"no_such_key\"),          KeyError = function(e) NULL) ## NULL st$set(\"foo\", letters) ok <- st$driver$del_object(st$get_hash(\"foo\")) st$flush_cache() tryCatch(st$get(\"foo\"),          KeyError = function(e) NULL,          HashError = function(e) message(\"Data is deleted\")) ## Data is deleted"},{"path":"https://richfitz.github.io/storr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rich FitzJohn. Author, maintainer. William Michael Landau. Contributor.","code":""},{"path":"https://richfitz.github.io/storr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"FitzJohn R (2025). storr: Simple Key Value Stores. R package version 1.2.6, https://richfitz.github.io/storr/.","code":"@Manual{,   title = {storr: Simple Key Value Stores},   author = {Rich FitzJohn},   year = {2025},   note = {R package version 1.2.6},   url = {https://richfitz.github.io/storr/}, }"},{"path":"https://richfitz.github.io/storr/index.html","id":"storr","dir":"","previous_headings":"","what":"Simple Key Value Stores","title":"Simple Key Value Stores","text":"Simple object cacher R. storr acts simple key-value store (supporting get/set/del arbitrary R objects data). actual storage can transient persistent, local distributed without changing interface. allow distributed access, data returned content rather simply key (key/content lookup step) another process changes data, storr retrieve current version. Cached -memory copies might faster retrieve -disk/database copies Content-addressable storage, storing retrieving potentially fewer copies identical data (useful lookup slow network) make system somewhat robust face multiple accessing processes Fetch external source (e.g. website) key found locally environment (memory) rds (disk) SQLite (via RSQLite) Postgres (via RPostgres) Redis (provided redux) rlite (via rrlite, interface function redux) disk memory-mapped file interface implemented thor storr always goes back common storage (database, filesystem, whatever) current object hash mapping, ensuring consistency using multiple processes. However, retrieving writing data given hash can often avoid accessing underlying storage. means repeated lookups happen quickly still able reflect changes elsewhere; time savings can substantial large objects stored.","code":""},{"path":"https://richfitz.github.io/storr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simple Key Value Stores","text":"CRAN install development version ","code":"install.packages(\"storr\") remotes::install_github(\"richfitz/storr@develop\", upgrade = FALSE)"},{"path":"https://richfitz.github.io/storr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Simple Key Value Stores","text":"storr comes two vignettes: storr vignette(\"storr\") outlines basic use core implementation details. external vignette(\"external\") shows use storr cache external resources files, web resources, etc, using storr_external object.","code":""},{"path":"https://richfitz.github.io/storr/reference/driver_remote.html","id":null,"dir":"Reference","previous_headings":"","what":"Remote storr — driver_remote","title":"Remote storr — driver_remote","text":"Create storr keeps rds-serialised objects remote location.  abstract interface (anything useful) can used file operation driver store files elsewhere.  intended end-user use storr_remote function.  Instead function designed support external packages implement details.  worked example, see package tests (helper-remote.R).  current implementation build driver_rds driver copying files remote location.","code":""},{"path":"https://richfitz.github.io/storr/reference/driver_remote.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remote storr — driver_remote","text":"","code":"driver_remote(ops, ..., path_local = NULL)"},{"path":"https://richfitz.github.io/storr/reference/driver_remote.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remote storr — driver_remote","text":"ops file operations object.  See tests now see required implement one. ... Arguments pass driver_rds, including compress, mangle_key, mangle_key_pad hash_algorithm. path_local Path local cache.  can left NULL, case per-session cache used. Alternatively, explicitly set path cache can reused sessions.  storr values (.e., objects) cached - key--value mapping always fetched remote storage.","code":""},{"path":"https://richfitz.github.io/storr/reference/driver_remote.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Remote storr — driver_remote","text":"Rich FitzJohn","code":""},{"path":"https://richfitz.github.io/storr/reference/encode64.html","id":null,"dir":"Reference","previous_headings":"","what":"Base64 encoding and decoding — encode64","title":"Base64 encoding and decoding — encode64","text":"Base64 encoding.  default uses RFC 4648 dialect (file/url encoding) characters 62 63 \"-\" \"_\".  Pass \"+\" \"/\" get RFC 1421 variant (R packages base64 encoding).","code":""},{"path":"https://richfitz.github.io/storr/reference/encode64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base64 encoding and decoding — encode64","text":"","code":"encode64(x, char62 = \"-\", char63 = \"_\", pad = TRUE)  decode64(x, char62 = \"-\", char63 = \"_\", error = TRUE)"},{"path":"https://richfitz.github.io/storr/reference/encode64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Base64 encoding and decoding — encode64","text":"x string vector strings encode/decode char62 Character use 62nd index char63 Character use 63rd index pad Logical, indicating strings padded = characters (RFC 4648 requires) error Throw error decoding fails.  FALSE NA_character_ values returned failures.","code":""},{"path":"https://richfitz.github.io/storr/reference/encode64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Base64 encoding and decoding — encode64","text":"","code":"x <- encode64(\"hello\") x #> [1] \"aGVsbG8=\" decode64(x) #> [1] \"hello\"  # Encoding things into filename-safe strings is the reason for # this function: encode64(\"unlikely/to be @ valid filename\") #> [1] \"dW5saWtlbHkvdG8gYmUgQCB2YWxpZCBmaWxlbmFtZQ==\""},{"path":"https://richfitz.github.io/storr/reference/fetch_hook_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Hook to fetch a resource from a file. — fetch_hook_read","title":"Hook to fetch a resource from a file. — fetch_hook_read","text":"Hook fetch resource file, use driver_external.  take two functions arguments: first converts key/namespace pair filename, second reads filename.  many R functions support reading URLs fetch_hook_read can used read remote resources.","code":""},{"path":"https://richfitz.github.io/storr/reference/fetch_hook_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hook to fetch a resource from a file. — fetch_hook_read","text":"","code":"fetch_hook_read(fpath, fread)"},{"path":"https://richfitz.github.io/storr/reference/fetch_hook_read.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hook to fetch a resource from a file. — fetch_hook_read","text":"fpath Function convert key, namespace file path fread Function converting filename R object","code":""},{"path":"https://richfitz.github.io/storr/reference/fetch_hook_read.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hook to fetch a resource from a file. — fetch_hook_read","text":"information using , see storr_external (can used fetch_hook argument) vignette: vignette(\"external\")","code":""},{"path":"https://richfitz.github.io/storr/reference/fetch_hook_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hook to fetch a resource from a file. — fetch_hook_read","text":"","code":"hook <- fetch_hook_read(     function(key, namespace) paste0(key, \".csv\"),     function(filename) read.csv(filename, stringsAsFactors = FALSE))"},{"path":"https://richfitz.github.io/storr/reference/join_key_namespace.html","id":null,"dir":"Reference","previous_headings":"","what":"Recycle key and namespace — join_key_namespace","title":"Recycle key and namespace — join_key_namespace","text":"Utility function driver authors","code":""},{"path":"https://richfitz.github.io/storr/reference/join_key_namespace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recycle key and namespace — join_key_namespace","text":"","code":"join_key_namespace(key, namespace)"},{"path":"https://richfitz.github.io/storr/reference/join_key_namespace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recycle key and namespace — join_key_namespace","text":"key vector keys namespace vector namespace","code":""},{"path":"https://richfitz.github.io/storr/reference/join_key_namespace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recycle key and namespace — join_key_namespace","text":"list elements n, key namespace","code":""},{"path":"https://richfitz.github.io/storr/reference/join_key_namespace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recycle key and namespace — join_key_namespace","text":"exists join, predictably, keys namespaces operations like mget.  Given vector scalar key namespace work required length recycle key namespace appropriate length.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr-defunct.html","id":null,"dir":"Reference","previous_headings":"","what":"Defunct functions — driver_redis_api","title":"Defunct functions — driver_redis_api","text":"Defunct functions","code":""},{"path":"https://richfitz.github.io/storr/reference/storr-defunct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defunct functions — driver_redis_api","text":"","code":"driver_redis_api(...)  storr_redis_api(...)"},{"path":"https://richfitz.github.io/storr/reference/storr-defunct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defunct functions — driver_redis_api","text":"... parameters (now dropped dots)","code":""},{"path":"https://richfitz.github.io/storr/reference/storr-defunct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Defunct functions — driver_redis_api","text":"Redis functions (driver_redis_api storr_redis_api) moved package redux.  believe anyone using time move done fairly abruptly - unfortunate, necessary avoid circular dependency!  new functions simply redux::driver_redis_api redux::storr_redis_api, along helper function redux::storr_hiredis also creates connection.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr.html","id":null,"dir":"Reference","previous_headings":"","what":"Object cache — storr","title":"Object cache — storr","text":"Create object cache; \"storr\".  storr simple key-value store actual content stored content-addressable way (duplicate objects stored ) caching layer repeated lookups fast even underlying storage driver slow.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object cache — storr","text":"","code":"storr(driver, default_namespace = \"objects\")"},{"path":"https://richfitz.github.io/storr/reference/storr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object cache — storr","text":"driver driver object default_namespace Default namespace store objects . default \"objects\" used, might useful two different storr objects pointing underlying storage, storing things different namespaces.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Object cache — storr","text":"create storr need provide \"driver\" object.  three package: driver_environment ephemeral -memory storage, driver_rds serialized storage disk, driver_dbi use DBI-compliant database interfaces. redux package (CRAN) provides storr driver uses Redis. convenience functions (e.g., storr_environment storr_rds) may convenient use function. storr made provides number methods. storr uses R6 (R6::R6Class) objects, method accessed using $ storr object (see examples).  methods described \"Methods\" section. default_namespace affects methods storr object refer namespaces; namespace given, action (get, set, del, list, import, export) affect default_namespace.  default \"objects\".","code":""},{"path":"https://richfitz.github.io/storr/reference/storr.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Object cache — storr","text":"destroy Totally destroys storr telling driver destroy data deleting driver.  remove data undone. Usage: destroy() flush_cache Flush temporary cache objects accumulates storr used.  need called often. Usage: flush_cache() set Set key value. Usage: set(key, value, namespace = self$default_namespace, use_cache = TRUE) Arguments: key:   key name.  Can string.   Value: Invisibly, hash saved object. set_by_value Like set saves object key hash object.  Equivalent $set(digest::digest(value), value). Usage: set_by_value(value, namespace = self$default_namespace, use_cache = TRUE) Arguments: value:   R object save, limitations set.   get Retrieve object storr.  requested value found KeyError raised (R error, can caught tryCatch; see \"storr\" vignette). Usage: get(key, namespace = self$default_namespace, use_cache = TRUE) Arguments: key:   name key get.   get_hash Retrieve hash object stored storr (rather object ). Usage: get_hash(key, namespace = self$default_namespace) Arguments: key:   name key get.   del Delete object storr. Usage: del(key, namespace = self$default_namespace) Arguments: key:   vector names keys   Value: logical vector length recycled length key/namespace, element TRUE object deleted, FALSE otherwise. duplicate Duplicate value set keys second set keys. value stored key just hash content, operation efficient - make copy data, just pointer data (details see storr vignette explains storage model detail).  Multiple keys (/namespaces) can provided, keys namespaces recycled needed.  However, number source destination keys must .  order operation defined, sets keys overlapping undefined behaviour. Usage: duplicate(key_src, key_dest, namespace = self$default_namespace,       namespace_src = namespace, namespace_dest = namespace) Arguments: key_src:   source key (vector keys)   fill Set one keys (potentially across namespaces) value, without duplication effort serialisation, duplicating data. Usage: fill(key, value, namespace = self$default_namespace, use_cache = TRUE) Arguments: key:   vector keys get; zero many valid keys   clear Clear storr.  function might slow iterate key.  Future versions storr might allow drivers implement bulk clear method allow faster clearing. Usage: clear(namespace = self$default_namespace) Arguments: namespace:   namespace, clear single namespace, NULL clear namespaces. exists Test key exists within namespace Usage: exists(key, namespace = self$default_namespace) Arguments: key:   vector names keys   Value: logical vector length recycled length key/namespace, element TRUE object exists FALSE otherwise. exists_object Test object given hash exists within storr Usage: exists_object(hash) Arguments: hash:   Hash test mset Set multiple elements Usage: mset(key, value, namespace = self$default_namespace, use_cache = TRUE) Arguments: key:   vector keys set; zero many valid keys   Details: arguments key namespace recycled either can given scalar vector. recycling allowed. mget Get multiple elements Usage: mget(key, namespace = self$default_namespace, use_cache = TRUE,       missing = NULL) Arguments: key:   vector keys get; zero many valid keys   Details: arguments key namespace recycled either can given scalar vector. recycling allowed. Value: list length recycled length key namespace.  elements missing, attribute missing indicate elements missing (integer vector indices values found storr). mset_by_value Set multiple elements , value.  cross mset set_by_value. Usage: mset_by_value(value, namespace = self$default_namespace, use_cache = TRUE) Arguments: value:   list vector values set storr.   gc Garbage collect storr.  keys directly map objects, instead map hashes map objects, possible hash/object pairs can persist nothing pointing .  Running gc remove objects storr. Usage: gc() get_value Get content object given hash. Usage: get_value(hash, use_cache = TRUE) Arguments: hash:   hash object retrieve.   Value: object present, otherwise throw HashError. set_value Add object value, add key.  need use often, used internally. Usage: set_value(value, use_cache = TRUE) Arguments: value:   R object set.   Value: Invisibly, hash object. mset_value Add vector object values, add keys.  need use often, used internally. Usage: mset_value(values, use_cache = TRUE) Arguments: values:   list R objects set   list List keys stored namespace. Usage: list(namespace = self$default_namespace) Arguments: namespace:   namespace list keys within. Value: sorted character vector (possibly zero-length). list_hashes List hashes stored storr Usage: list_hashes() Value: sorted character vector (possibly zero-length). list_namespaces List namespaces known database Usage: list_namespaces() Value: sorted character vector (possibly zero-length). import Import R objects environment. Usage: import(src, list = NULL, namespace = self$default_namespace,       skip_missing = FALSE) Arguments: src:   Object import objects ; can list, environment another storr.   export Export objects storr something else. Usage: export(dest, list = NULL, namespace = self$default_namespace,       skip_missing = FALSE) Arguments: dest:   target destination export objects ; can list, environment, another storr.  Use list() export brand new list, use .list(object) shorthand.   Value: Invisibly, dest, allows use e <- st$export(new.env()) x <- st$export(list()). archive_export Export objects storr special \"archive\" storr, storr_rds name mangling turned (encodes keys base64 violate filesystem naming conventions). Usage: archive_export(path, names = NULL, namespace = NULL) Arguments: path:   Path create storr ; can exist already.   archive_import Inverse archive_export; import objects storr created archive_export. Usage: archive_import(path, names = NULL, namespace = NULL) Arguments: path:   Path exported storr.   index_export Generate data.frame index objects present storr. can saved (rds storr) lieu keys/ directory re-imported index_import.  provide version control friendly export data storr. Usage: index_export(namespace = NULL) Arguments: namespace:   Optional character vector namespaces export.  default export namespaces. index_import Import index. Usage: index_import(index) Arguments: index:   Must data.frame columns 'namespace', 'key' 'hash' (order).  error hashes present storr.","code":"\\item{\\code{value}:   Any R object to store.  The object will generally be serialized (this is not actually true for the environment storr) so only objects that would usually be expected to survive a `saveRDS`/`readRDS` roundtrip will work.  This excludes Rcpp modules objects, external pointers, etc.  But any \"normal\" R object will work fine. }  \\item{\\code{namespace}:   An optional namespace.  By default the default namespace that the storr was created with will be used (by default that is \"objects\").  Different namespaces allow different types of objects to be stored without risk of names colliding.  Use of namespaces is optional, but if used they must be a string. }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{namespace}:   Optional namespace to save the key into. }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{namespace}:   Optional namespace to look for the key within. }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{namespace}:   Optional namespace to look for the key within. } \\item{\\code{namespace}:   The namespace of the key. } \\item{\\code{key_dest}:   The destination key }  \\item{\\code{namespace}:   The namespace to copy keys within (used only of `namespace_src` and `namespace_dest` are not provided }  \\item{\\code{namespace_src}:   The source namespace - use this where keys are duplicated across namespaces. }  \\item{\\code{namespace_dest}:   The destination namespace - use this where keys are duplicated across namespaces. } \\item{\\code{value}:   A single value to set all keys to }  \\item{\\code{namespace}:   A vector of namespaces (either a single namespace or a vector) }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{namespace}:   The namespace of the key. } \\item{\\code{value}:   A vector of values }  \\item{\\code{namespace}:   A vector of namespaces (either a single namespace or a vector) }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{namespace}:   A vector of namespaces (either a single namespace or a vector) }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). }  \\item{\\code{missing}:   Value to use for missing elements; by default `NULL` will be used.  IF `NULL` is a value that you might have stored in the storr you might want to use a different value here to distinguish \"missing\" from \"set to NULL\".  In addition, the `missing` attribute will indicate which values were missing. } \\item{\\code{namespace}:   A vector of namespaces }  \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{use_cache}:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before). } \\item{\\code{list}:   Names of of objects to import (or `NULL` to import all objects in `envir`.  If given it must be a character vector.  If named, the names of the character vector will be the names of the objects as created in the storr. }  \\item{\\code{namespace}:   Namespace to get objects from, and to put objects into.  If `NULL`, all namespaces from `src` will be imported. If named, then the same rule is followed as `list`; `namespace = c(a = b)` will import the contents of namespace `b` as namespace `a`. }  \\item{\\code{skip_missing}:   Logical, indicating if missing keys (specified in `list`) should be skipped over, rather than being treated as an error (the default). } \\item{\\code{list}:   Names of objects to export, with the same rules as `list` in `$import`. }  \\item{\\code{namespace}:   Namespace to get objects from, and to put objects into.  If `NULL`, then this will export namespaces from this (source) storr into the destination; if there is more than one namespace,this is only possible if `dest` is a storr (otherwise there will be an error). }  \\item{\\code{skip_missing}:   Logical, indicating if missing keys (specified in `list`) should be skipped over, rather than being treated as an error (the default). } \\item{\\code{names}:   As for `$export` }  \\item{\\code{namespace}:   Namespace to get objects from.  If `NULL`, then exports all namespaces found in this (source) storr. } \\item{\\code{names}:   As for `$import` }  \\item{\\code{namespace}:   Namespace to import objects into.  If `NULL`, then imports all namespaces from the source storr. }"},{"path":"https://richfitz.github.io/storr/reference/storr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object cache — storr","text":"","code":"st <- storr(driver_environment()) ## Set \"mykey\" to hold the mtcars dataset: st$set(\"mykey\", mtcars) ## and get the object: st$get(\"mykey\") #>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 #> Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 #> Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 #> Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 #> Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 #> Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 #> Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 #> Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 #> Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 #> Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 #> Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 #> Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 #> Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 #> Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 #> Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 #> Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 #> Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 #> Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 #> Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 #> AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 #> Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 #> Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 #> Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 #> Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 #> Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 #> Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 #> Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 #> Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 #> Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 ## List known keys: st$list() #> [1] \"mykey\" ## List hashes st$list_hashes() #> [1] \"a63c70e73b58d0823ab3bcbd3b543d6f\" ## List keys in another namespace: st$list(\"namespace2\") #> character(0) ## We can store things in other namespaces: st$set(\"x\", mtcars, \"namespace2\") st$set(\"y\", mtcars, \"namespace2\") st$list(\"namespace2\") #> [1] \"x\" \"y\" ## Duplicate data do not cause duplicate storage: despite having three ## keys we only have one bit of data: st$list_hashes() #> [1] \"a63c70e73b58d0823ab3bcbd3b543d6f\" st$del(\"mykey\")  ## Storr objects can be created that have a default namespace that is ## not \"objects\" by using the `default_namespace` argument (this ## one also points at the same memory as the first storr). st2 <- storr(driver_environment(st$driver$envir),              default_namespace = \"namespace2\") ## All functions now use \"namespace2\" as the default namespace: st2$list() #> [1] \"x\" \"y\" st2$del(\"x\") st2$del(\"y\")"},{"path":"https://richfitz.github.io/storr/reference/storr_dbi.html","id":null,"dir":"Reference","previous_headings":"","what":"DBI storr driver — storr_dbi","title":"DBI storr driver — storr_dbi","text":"Object cache driver using \"DBI\" package interface storage. means storr can work supported \"DBI\" driver (though practically works SQLite Postgres MySQL dialect translation done).  connect, must provide driver object (e.g., RSQLite::SQLite(), RPostgres::Postgres() first argument.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_dbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI storr driver — storr_dbi","text":"","code":"storr_dbi(   tbl_data,   tbl_keys,   con,   args = NULL,   binary = NULL,   hash_algorithm = NULL,   default_namespace = \"objects\" )  driver_dbi(   tbl_data,   tbl_keys,   con,   args = NULL,   binary = NULL,   hash_algorithm = NULL )"},{"path":"https://richfitz.github.io/storr/reference/storr_dbi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DBI storr driver — storr_dbi","text":"tbl_data Name table maps hashes values tbl_keys Name table maps keys hashes con Either DBI connection DBI driver (see example) args Arguments pass, along driver, DBI::dbConnect con driver. binary Optional logical indicating values stored binary.  possible, (potentially faster) accurate.  However, present supported recent DBI RSQLite packages, DBI drivers, actually faster.  given (.e., NULL), binary storage used possible creating new tables, tables exist, use whatever used existing tables. hash_algorithm Name hash algorithm use.  Possible values \"md5\", \"sha1\", others supported digest::digest.  given, default \"md5\". default_namespace Default namespace (see storr).","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_dbi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DBI storr driver — storr_dbi","text":"DBI package specifies uniform interface using DBI compliant databases, need provide connection object.  storr anything help create connection object . DBI storr driver works using two tables; one mapping keys hashes, one mapping hashes values.  Two table names need provided ; must different treated opaque (use anything else - reading writing).  Apart names matter. treatment binary data underlying DBI drivers, binary serialisation faster (might slightly slower ) string serialisation, contrast experience backends. storr uses DBI's \"prepared query\" approach safely interpolate keys, namespaces values database - allow odd characters without throwing SQL syntax errors.  Table names interpolated way - storr simply quotes, validates beforehand ensure tbl_data tbl_keys contain quotes. aware $destroy() close connection database.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_dbi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DBI storr driver — storr_dbi","text":"","code":"if (requireNamespace(\"RSQLite\", quietly = TRUE)) {   st <- storr::storr_dbi(\"tblData\", \"tblKeys\", RSQLite::SQLite(),                          \":memory:\")    # Set some data:   st$set(\"foo\", runif(10))   st$list()    # And retrieve the data:   st$get(\"foo\")    # These are the data tables; treat these as read only   DBI::dbListTables(st$driver$con)    # With recent RSQLite you'll get binary storage here:   st$driver$binary    # The entire storr part of the database can be removed using   # \"destroy\"; this will also close the connection to the database   st$destroy()    # If you have a connection you want to reuse (which will the the   # case if you are using an in-memory SQLite database for   # multiple things within an application) it may be useful to   # pass the connection object instead of the driver:   con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")   st <- storr::storr_dbi(\"tblData\", \"tblKeys\", con)   st$set(\"foo\", runif(10))    # You can then connect a different storr to the same underlying   # storage   st2 <- storr::storr_dbi(\"tblData\", \"tblKeys\", con)   st2$get(\"foo\") } #>  [1] 0.87460066 0.17494063 0.03424133 0.32038573 0.40232824 0.19566983 #>  [7] 0.40353812 0.06366146 0.38870131 0.97554784"},{"path":"https://richfitz.github.io/storr/reference/storr_environment.html","id":null,"dir":"Reference","previous_headings":"","what":"Environment object cache driver — storr_environment","title":"Environment object cache driver — storr_environment","text":"Fast transient environment driver.  driver saves objects local R environment, without serialisation.  makes lookup fast saved across sessions.  environment storr can made persistent saving file storr though.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_environment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Environment object cache driver — storr_environment","text":"","code":"storr_environment(   envir = NULL,   hash_algorithm = NULL,   default_namespace = \"objects\" )  driver_environment(envir = NULL, hash_algorithm = NULL)"},{"path":"https://richfitz.github.io/storr/reference/storr_environment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Environment object cache driver — storr_environment","text":"envir environment point storr .  default creates new empty environment generally right choice.  However, want multiple environment storrs pointing environment pass envir argument along. hash_algorithm Name hash algorithm use.  Possible values \"md5\", \"sha1\", others supported digest::digest.  given, default \"md5\". default_namespace Default namespace (see storr).","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_environment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Environment object cache driver — storr_environment","text":"","code":"# Create an environment and stick some random numbers into it: st <- storr_environment() st$set(\"foo\", runif(10)) st$get(\"foo\") #>  [1] 0.28989230 0.67838043 0.73531960 0.19595673 0.98053967 0.74152153 #>  [7] 0.05144628 0.53021246 0.69582388 0.68855600  # To make this environment persistent we can save it to disk: path <- tempfile() st2 <- st$archive_export(path) # st2 is now a storr_rds (see ?storr_rds), and will persist across # sessions.  # or export to a new list: lis <- st$export(list()) lis #> $foo #>  [1] 0.28989230 0.67838043 0.73531960 0.19595673 0.98053967 0.74152153 #>  [7] 0.05144628 0.53021246 0.69582388 0.68855600 #>"},{"path":"https://richfitz.github.io/storr/reference/storr_external.html","id":null,"dir":"Reference","previous_headings":"","what":"Storr that looks for external resources — storr_external","title":"Storr that looks for external resources — storr_external","text":"storr fetching external resources.  driver used try fetch external data source resource can found locally.  works checking see key present storr (returning ).  found, function fetch_hook run fetch .","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_external.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Storr that looks for external resources — storr_external","text":"","code":"storr_external(storage_driver, fetch_hook, default_namespace = \"objects\")"},{"path":"https://richfitz.github.io/storr/reference/storr_external.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Storr that looks for external resources — storr_external","text":"storage_driver Another storr driver handle actual storage. fetch_hook function run fetch data key found store.  function must take arguments key namespace return R object.  must throw error external resource resolved. default_namespace Default namespace (see storr)","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_external.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Storr that looks for external resources — storr_external","text":"See vignette vignette(\"external\") much detail. function likely useful things like caching resources websites, computing long-running quantities demand.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_multistorr.html","id":null,"dir":"Reference","previous_headings":"","what":"Storr with multiple storage drivers — storr_multistorr","title":"Storr with multiple storage drivers — storr_multistorr","text":"Create special storr uses separate storage drivers keys (tend numerous small size) data (tends somewhat less numerous much larger size).  might useful use storage models different characteristics (memory/disk, etc).","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_multistorr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Storr with multiple storage drivers — storr_multistorr","text":"","code":"storr_multistorr(keys, data, default_namespace = \"objects\")"},{"path":"https://richfitz.github.io/storr/reference/storr_multistorr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Storr with multiple storage drivers — storr_multistorr","text":"keys Driver keys data Driver data default_namespace Default namespace (see storr)","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_multistorr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Storr with multiple storage drivers — storr_multistorr","text":"experimental feature somewhat subject change. particular, driver may develop ability store small data storr keys (say, 1kb) based tunable parameter. can attach another storr either data key storage (see example), able see keys data (respectively).  garbage collect data half, data lost!","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_multistorr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Storr with multiple storage drivers — storr_multistorr","text":"","code":"# Create a storr that is stores keys in an environment and data in # an rds path <- tempfile() st <- storr::storr_multistorr(driver_environment(),                               driver_rds(path)) st$set(\"a\", runif(10)) st$get(\"a\") #>  [1] 0.03123033 0.22556253 0.30083081 0.63646561 0.47902455 0.43217126 #>  [7] 0.70643384 0.94857658 0.18033877 0.21689988  # The data can be also seen by connecting to the rds store rds <- storr::storr_rds(path) rds$list() # empty #> character(0) rds$list_hashes() # here's the data #> [1] \"d94c5a60cf0f06b8f767e4e5a9585e1a\" rds$get_value(rds$list_hashes()) #>  [1] 0.03123033 0.22556253 0.30083081 0.63646561 0.47902455 0.43217126 #>  [7] 0.70643384 0.94857658 0.18033877 0.21689988  st$destroy()"},{"path":"https://richfitz.github.io/storr/reference/storr_rds.html","id":null,"dir":"Reference","previous_headings":"","what":"rds object cache driver — storr_rds","title":"rds object cache driver — storr_rds","text":"Object cache driver saves objects using R's native serialized file format (see saveRDS) filesystem.","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_rds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rds object cache driver — storr_rds","text":"","code":"storr_rds(   path,   compress = NULL,   mangle_key = NULL,   mangle_key_pad = NULL,   hash_algorithm = NULL,   default_namespace = \"objects\" )  driver_rds(   path,   compress = NULL,   mangle_key = NULL,   mangle_key_pad = NULL,   hash_algorithm = NULL )"},{"path":"https://richfitz.github.io/storr/reference/storr_rds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rds object cache driver — storr_rds","text":"path Path store.  tempdir() good choice ephemeral storage, rappdirs package (CRAN) might nice persistent application data. compress Compress generated file?  saves small amount space reasonable amount time. mangle_key Mangle keys?  TRUE, key encoded using base64 saving filesystem.  See Details. mangle_key_pad Logical indicating filenames created using mangle_key also \"padded\" = character make round number bytes.  Padding required satisfy document describes base64 encoding (RFC 4648) can cause problems applications (see issue).  default pad new storr archives.  generally safe leave alone. hash_algorithm Name hash algorithm use.  Possible values \"md5\", \"sha1\", others supported digest::digest.  given, default \"md5\". default_namespace Default namespace (see storr).","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_rds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rds object cache driver — storr_rds","text":"mangle_key argument run key created \"base 64\" encoding.  means keys include symbols invalid filesystems (e.g, \"/\", \":\") replaced harmless characters.  RFC 4648 dialect used \"-\" \"_\" used character 62 63 (differs R base64 encoders).  mangling designed transparent user – storr appear store things unmangled keys names stored files different. Note (namespace mangled (least yet) needs contain characters valid filename. actual file stored mangled names safe use path storr without mangling.  rds storr created \"mangledness\" set.  Using mangle_key = NULL uses whatever mangledness exists (mangledness creating new storr).","code":""},{"path":"https://richfitz.github.io/storr/reference/storr_rds.html","id":"corrupt-keys","dir":"Reference","previous_headings":"","what":"Corrupt keys","title":"rds object cache driver — storr_rds","text":"file synchronisation utilities like Dropbox can create file confuse rds storr (e.g., \"myobject (Someone's conflicted copy)\".  mangle_key FALSE detected time real problem storr.  However, mangle_key TRUE keys base64 encoded conflicted copies can break parts storr. see warning asking deal files, please delete offending files; path printed along files causing problem. Alternatively, can try (assuming storr object st) running   delete corrupted keys confirmation.  messages printed screen printed default per minute per namespace.  can control setting R option storr.corrupt.notice.period - setting NA suppresses notice otherwise interpreted number seconds.","code":"st$driver$purge_corrupt_keys()"},{"path":"https://richfitz.github.io/storr/reference/storr_rds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rds object cache driver — storr_rds","text":"","code":"# Create an rds storr in R's temporary directory: st <- storr_rds(tempfile())  # Store some data (10 random numbers against the key \"foo\") st$set(\"foo\", runif(10)) st$list() #> [1] \"foo\"  # And retrieve the data: st$get(\"foo\") #>  [1] 0.68016292 0.49884561 0.64167935 0.66028435 0.09602416 0.76560016 #>  [7] 0.76967480 0.99071231 0.97052090 0.38918276  # Keys that are not valid filenames will cause issues.  This will # cause an error: if (FALSE) { # \\dontrun{ st$set(\"foo/bar\", letters) } # }  # The solution to this is to \"mangle\" the key names.  Storr can do # this for you: st2 <- storr_rds(tempfile(), mangle_key = TRUE) st2$set(\"foo/bar\", letters) st2$list() #> [1] \"foo/bar\" st2$get(\"foo/bar\") #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # Behind the scenes, storr is safely encoding the filenames with base64: dir(file.path(st2$driver$path, \"keys\", \"objects\")) #> [1] \"Zm9vL2Jhcg\"  # Clean up the two storrs: st$destroy() st2$destroy()"},{"path":"https://richfitz.github.io/storr/reference/test_driver.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a storr driver — test_driver","title":"Test a storr driver — test_driver","text":"Test driver passes storr tests.  page interest people developing storr drivers; nothing required using storr.","code":""},{"path":"https://richfitz.github.io/storr/reference/test_driver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a storr driver — test_driver","text":"","code":"test_driver(create)"},{"path":"https://richfitz.github.io/storr/reference/test_driver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a storr driver — test_driver","text":"create function one arguments run NULL argument create new driver instance.  also called driver (type) argument - case, must create new driver object pointing underlying storage (see examples). Depending storage model, temporary directories, -memory locations, random--unique prefixes may help create isolated locations test (tests assume storr created create entirely empty).","code":""},{"path":"https://richfitz.github.io/storr/reference/test_driver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a storr driver — test_driver","text":"run suite functions test driver likely behave .  bugs found added test suite guard regressions. test suite included package system.file(\"spec\", package = \"storr\"). procedure test block : Create new driver running dr <- create() Run number tests. Destroy driver running dr$destroy() running test suite, make sure harm precious data!","code":""},{"path":"https://richfitz.github.io/storr/reference/test_driver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a storr driver — test_driver","text":"","code":"## Testing the environment driver is nice and fast: if (requireNamespace(\"testthat\")) {   create_env <- function(dr = NULL, ...) {     driver_environment(dr$envir, ...)   }   test_driver(create_env) } #> Loading required namespace: testthat  # To test things like the rds driver, I would run: if (FALSE) { # \\dontrun{ if (requireNamespace(\"testthat\")) {   create_rds <- function(dr = NULL) {     driver_rds(if (is.null(dr)) tempfile() else dr$path)   }   test_driver(create_rds) } } # }"},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-124-2020-10-12","dir":"Changelog","previous_headings":"","what":"storr 1.2.4 (2020-10-12)","title":"storr 1.2.4 (2020-10-12)","text":"CRAN release: 2020-10-12 Speed $get_hash() method RDS drivers using C code traits (#96, #98, @wlandau).","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-121-2018-10-18","dir":"Changelog","previous_headings":"","what":"storr 1.2.1 (2018-10-18)","title":"storr 1.2.1 (2018-10-18)","text":"CRAN release: 2018-10-18 Avoid race condition writing rds storrs parallel (#80, reported @wlandau)","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-120-2018-05-31","dir":"Changelog","previous_headings":"","what":"storr 1.2.0 (2018-05-31)","title":"storr 1.2.0 (2018-05-31)","text":"CRAN release: 2018-05-31 New index function (#22, requested @wlandau) Support creating storrs different storage keys data (driver_multistorr storr_multistorr, #67) New repair methods ($check $repair) detecting problems storr repositories. work progress currently supported rds driver. Support infrastructure “remote storr” databases, can used create storr rds objects remote location (#61). implement useful remote storrs, provides support .","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-113-2017-12-15","dir":"Changelog","previous_headings":"","what":"storr 1.1.3 (2017-12-15)","title":"storr 1.1.3 (2017-12-15)","text":"CRAN release: 2017-12-15 use version 2 serialisation, avoiding breakage version 3 released 3.5.0 (#62, reported Tomas Kalibera) Quote SQL safely (#60, reported @wlandau) Support duplicating ($duplicate) filling ($fill) keys identical values, without duplicating reserialising data (#56, requested @wlandau) Moved shiny new pkgdown website - https://richfitz.github.com/storr","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-112-2017-09-08","dir":"Changelog","previous_headings":"","what":"storr 1.1.2 (2017-09-08)","title":"storr 1.1.2 (2017-09-08)","text":"CRAN release: 2017-09-08 Use full path storrs still work working directory changes (#50, #51, @wlandau) Avoid DBI disconnection warnings running tests Avoid running Redis tests inappropriate settings (#52, #53, thanks @wlandau) Move Redis code entirely redux","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-111-2017-06-02","dir":"Changelog","previous_headings":"","what":"storr 1.1.1 (2017-06-02)","title":"storr 1.1.1 (2017-06-02)","text":"CRAN release: 2017-06-02 Fix bug padding base64 encoded filenames (exposed using vectorised interface","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-110-2017-05-05","dir":"Changelog","previous_headings":"","what":"storr 1.1.0 (2017-05-05)","title":"storr 1.1.0 (2017-05-05)","text":"CRAN release: 2017-05-05 Support using relational databases via DBI (SQLite, Postgres) #23 - MySQL Microsoft SQL Server support implemented yet Support selecting hash algorithm driver level, rather limited md5, robust algorithms can used. implemented storr drivers, rds driver safely work storr databases version mget/mset/mset_by_value added vectorised get/set/set_by_value operations reduce number roundtrips drivers. del exists become vectorised time. requires extensive change drivers backward compatible users. Large object support rds slightly improved (#25) still slow Storr now supports exporting multiple namespaces (possibly namespaces) making easier migrate large amounts data storrs. cause small breaking change $import() now returns matrix columns name, namespace indicating imported (previously just vector) Storr import/export gracefully handles missing keys RDS storrs longer pad base64 filenames trailing = reduces number possibly problematic characters. Existing storrs unaffected (#43) RDS storrs left inconsistent state RDS file writing fails (#40, thanks @krlmlr)","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-101-2016-05-10","dir":"Changelog","previous_headings":"","what":"storr 1.0.1 (2016-05-10)","title":"storr 1.0.1 (2016-05-10)","text":"CRAN release: 2016-05-11 Updated work recent testthat (>= 1.0.0) Limited support writing large serialised objects (rds)","code":""},{"path":"https://richfitz.github.io/storr/news/index.html","id":"storr-100-2016-01-19","dir":"Changelog","previous_headings":"","what":"storr 1.0.0 (2016-01-19)","title":"storr 1.0.0 (2016-01-19)","text":"CRAN release: 2016-01-20 Initial CRAN release","code":""}]
