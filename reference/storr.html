<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Object cache — storr • storr</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Object cache — storr"><meta name="description" content='Create an object cache; a "storr".  A storr is a simple key-value
store where the actual content is stored in a content-addressable
way (so that duplicate objects are only stored once) and with a
caching layer so that repeated lookups are fast even if the
underlying storage driver is slow.'><meta property="og:description" content='Create an object cache; a "storr".  A storr is a simple key-value
store where the actual content is stored in a content-addressable
way (so that duplicate objects are only stored once) and with a
caching layer so that repeated lookups are fast even if the
underlying storage driver is slow.'></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">storr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.6</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/storr.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/external.html">external</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/richfitz/storr/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Object cache</h1>
      <small class="dont-index">Source: <a href="https://github.com/richfitz/storr/blob/master/R/storr.R" class="external-link"><code>R/storr.R</code></a></small>
      <div class="d-none name"><code>storr.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Create an object cache; a "storr".  A storr is a simple key-value
store where the actual content is stored in a content-addressable
way (so that duplicate objects are only stored once) and with a
caching layer so that repeated lookups are fast even if the
underlying storage driver is slow.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">storr</span><span class="op">(</span><span class="va">driver</span>, default_namespace <span class="op">=</span> <span class="st">"objects"</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-driver">driver<a class="anchor" aria-label="anchor" href="#arg-driver"></a></dt>
<dd><p>A driver object</p></dd>


<dt id="arg-default-namespace">default_namespace<a class="anchor" aria-label="anchor" href="#arg-default-namespace"></a></dt>
<dd><p>Default namespace to store objects in.
By default <code>"objects"</code> is used, but this might be useful to have
two different <code>storr</code> objects pointing at the same
underlying storage, but storing things in different namespaces.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>To create a storr you need to provide a "driver" object.  There
are three in this package: <a href="storr_environment.html">driver_environment</a> for ephemeral
in-memory storage, <a href="storr_rds.html">driver_rds</a> for serialized storage to disk,
and <a href="storr_dbi.html">driver_dbi</a> for use with DBI-compliant database interfaces.
The <code>redux</code> package (on CRAN) provides a storr driver that uses
Redis.</p>
<p>There are convenience functions (e.g., <a href="storr_environment.html">storr_environment</a> and
<a href="storr_rds.html">storr_rds</a>) that may be more convenient to use than this
function.</p>
<p>Once a storr has been made it provides a number of methods.
Because storr uses <code>R6</code> (<a href="https://r6.r-lib.org/reference/R6Class.html" class="external-link">R6::R6Class</a>) objects, each
method is accessed by using <code>$</code> on a storr object (see the
examples).  The methods are described below in the "Methods"
section.</p>
<p>The <code>default_namespace</code> affects all methods of the storr object
that refer to namespaces; if a namespace is not given, then the
action (get, set, del, list, import, export) will affect the
<code>default_namespace</code>.  By default this is <code>"objects"</code>.</p>
    </div>
    <div class="section level2">
    <h2 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a></h2>



<dl><dt><code>destroy</code></dt>
<dd><p>Totally destroys the storr by telling the driver to destroy all the data and then deleting the driver.  This will remove all data and cannot be undone.</p>
<p><em>Usage:</em>
<code>destroy()</code></p></dd>

<dt><code>flush_cache</code></dt>
<dd><p>Flush the temporary cache of objects that accumulates as the storr is used.  Should not need to be called often.</p>
<p><em>Usage:</em>
<code>flush_cache()</code></p></dd>

<dt><code>set</code></dt>
<dd><p>Set a key to a value.</p>
<p><em>Usage:</em>
<code>set(key, value, namespace = self$default_namespace, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   The key name.  Can be any string.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{value}<span class="sc">:</span>   Any R object to store.  The object will generally be <span class="fu">serialized</span> (this is not actually true <span class="cf">for</span> the environment storr) so only objects that would usually be expected to survive a <span class="st">`</span><span class="at">saveRDS</span><span class="st">`</span><span class="sc">/</span><span class="st">`</span><span class="at">readRDS</span><span class="st">`</span> roundtrip will work.  This excludes Rcpp modules objects, external pointers, etc.  But any <span class="st">"normal"</span> R object will work fine.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   An optional namespace.  By default the default namespace that the storr was created with will be <span class="fu">used</span> (by default that is <span class="st">"objects"</span>).  Different namespaces allow different types of objects to be stored without risk of names colliding.  Use of namespaces is optional, but <span class="cf">if</span> used they must be a string.</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Value</em>:
Invisibly, the hash of the saved object.</p></dd>

<dt><code>set_by_value</code></dt>
<dd><p>Like <code>set</code> but saves the object with a key that is the same as the hash of the object.  Equivalent to <code>$set(digest::digest(value), value)</code>.</p>
<p><em>Usage:</em>
<code>set_by_value(value, namespace = self$default_namespace, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>value</code>:   An R object to save, with the same limitations as <code>set</code>.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Optional namespace to save the key into.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>get</code></dt>
<dd><p>Retrieve an object from the storr.  If the requested value is not found then a <code>KeyError</code> will be raised (an R error, but can be caught with <code>tryCatch</code>; see the "storr" vignette).</p>
<p><em>Usage:</em>
<code>get(key, namespace = self$default_namespace, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   The name of the key to get.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Optional namespace to look <span class="cf">for</span> the key within.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>get_hash</code></dt>
<dd><p>Retrieve the hash of an object stored in the storr (rather than the object itself).</p>
<p><em>Usage:</em>
<code>get_hash(key, namespace = self$default_namespace)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   The name of the key to get.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Optional namespace to look <span class="cf">for</span> the key within.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>del</code></dt>
<dd><p>Delete an object from the storr.</p>
<p><em>Usage:</em>
<code>del(key, namespace = self$default_namespace)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   A vector of names of keys</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   The namespace of the key.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Value</em>:
A logical vector the same length as the recycled length of key/namespace, with each element being <code>TRUE</code> if an object was deleted, <code>FALSE</code> otherwise.</p></dd>

<dt><code>duplicate</code></dt>
<dd><p>Duplicate the value of a set of keys into a second set of keys. Because the value stored against a key is just the hash of its content, this operation is very efficient - it does not make a copy of the data, just the pointer to the data (for more details see the storr vignette which explains the storage model in more detail).  Multiple keys (and/or namespaces) can be provided, with keys and namespaces recycled as needed.  However, the number of source and destination keys must be the same.  The order of operation is not defined, so if the sets of keys are overlapping it is undefined behaviour.</p>
<p><em>Usage:</em>
<code>duplicate(key_src, key_dest, namespace = self$default_namespace,
      namespace_src = namespace, namespace_dest = namespace)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key_src</code>:   The source key (or vector of keys)</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{key_dest}<span class="sc">:</span>   The destination key</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   The namespace to copy keys <span class="fu">within</span> (used only of <span class="st">`</span><span class="at">namespace_src</span><span class="st">`</span> and <span class="st">`</span><span class="at">namespace_dest</span><span class="st">`</span> are not provided</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="er">}</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{namespace_src}<span class="sc">:</span>   The source namespace <span class="sc">-</span> use this where keys are duplicated across namespaces.</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>\item{\code{namespace_dest}<span class="sc">:</span>   The destination namespace <span class="sc">-</span> use this where keys are duplicated across namespaces.</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>fill</code></dt>
<dd><p>Set one or more keys (potentially across namespaces) to the same value, without duplication effort serialisation, or duplicating data.</p>
<p><em>Usage:</em>
<code>fill(key, value, namespace = self$default_namespace, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   A vector of keys to get; zero to many valid keys</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{value}<span class="sc">:</span>   A single value to set all keys to</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   A vector of <span class="fu">namespaces</span> (either a single namespace or a vector)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>clear</code></dt>
<dd><p>Clear a storr.  This function might be slow as it will iterate over each key.  Future versions of storr might allow drivers to implement a bulk clear method that will allow faster clearing.</p>
<p><em>Usage:</em>
<code>clear(namespace = self$default_namespace)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>namespace</code>:   A namespace, to clear a single namespace, or <code>NULL</code> to clear all namespaces.</p></li>
</ul></dd>

<dt><code>exists</code></dt>
<dd><p>Test if a key exists within a namespace</p>
<p><em>Usage:</em>
<code>exists(key, namespace = self$default_namespace)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   A vector of names of keys</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   The namespace of the key.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Value</em>:
A logical vector the same length as the recycled length of key/namespace, with each element being <code>TRUE</code> if the object exists and <code>FALSE</code> otherwise.</p></dd>

<dt><code>exists_object</code></dt>
<dd><p>Test if an object with a given hash exists within the storr</p>
<p><em>Usage:</em>
<code>exists_object(hash)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>hash</code>:   Hash to test</p></li>
</ul></dd>

<dt><code>mset</code></dt>
<dd><p>Set multiple elements at once</p>
<p><em>Usage:</em>
<code>mset(key, value, namespace = self$default_namespace, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   A vector of keys to set; zero to many valid keys</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{value}<span class="sc">:</span>   A vector of values</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   A vector of <span class="fu">namespaces</span> (either a single namespace or a vector)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Details:</em>
The arguments <code>key</code> and <code>namespace</code> are recycled such that either can be given as a scalar if the other is a vector. Other recycling is not allowed.</p></dd>

<dt><code>mget</code></dt>
<dd><p>Get multiple elements at once</p>
<p><em>Usage:</em>
<code>mget(key, namespace = self$default_namespace, use_cache = TRUE,
      missing = NULL)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>key</code>:   A vector of keys to get; zero to many valid keys</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   A vector of <span class="fu">namespaces</span> (either a single namespace or a vector)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{missing}<span class="sc">:</span>   Value to use <span class="cf">for</span> missing elements; by default <span class="st">`</span><span class="at">NULL</span><span class="st">`</span> will be used.  IF <span class="st">`</span><span class="at">NULL</span><span class="st">`</span> is a value that you might have stored <span class="cf">in</span> the storr you might want to use a different value here to distinguish <span class="st">"missing"</span> from <span class="st">"set to NULL"</span>.  In addition, the <span class="st">`</span><span class="at">missing</span><span class="st">`</span> attribute will indicate which values were missing.</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Details:</em>
The arguments <code>key</code> and <code>namespace</code> are recycled such that either can be given as a scalar if the other is a vector. Other recycling is not allowed.</p>
<p><em>Value</em>:
A list with a length of the recycled length of <code>key</code> and <code>namespace</code>.  If any elements are missing, then an attribute <code>missing</code> will indicate the elements that are missing (this will be an integer vector with the indices of values were not found in the storr).</p></dd>

<dt><code>mset_by_value</code></dt>
<dd><p>Set multiple elements at once, by value.  A cross between <code>mset</code> and <code>set_by_value</code>.</p>
<p><em>Usage:</em>
<code>mset_by_value(value, namespace = self$default_namespace, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>value</code>:   A list or vector of values to set into the storr.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   A vector of namespaces</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>gc</code></dt>
<dd><p>Garbage collect the storr.  Because keys do not directly map to objects, but instead map to hashes which map to objects, it is possible that hash/object pairs can persist with nothing pointing at them.  Running <code>gc</code> will remove these objects from the storr.</p>
<p><em>Usage:</em>
<code><a href="https://rdrr.io/r/base/gc.html" class="external-link">gc()</a></code></p></dd>

<dt><code>get_value</code></dt>
<dd><p>Get the content of an object given its hash.</p>
<p><em>Usage:</em>
<code>get_value(hash, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>hash</code>:   The hash of the object to retrieve.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Value</em>:
The object if it is present, otherwise throw a <code>HashError</code>.</p></dd>

<dt><code>set_value</code></dt>
<dd><p>Add an object value, but don't add a key.  You will not need to use this very often, but it is used internally.</p>
<p><em>Usage:</em>
<code>set_value(value, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>value</code>:   An R object to set.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Value</em>:
Invisibly, the hash of the object.</p></dd>

<dt><code>mset_value</code></dt>
<dd><p>Add a vector of object values, but don't add keys.  You will not need to use this very often, but it is used internally.</p>
<p><em>Usage:</em>
<code>mset_value(values, use_cache = TRUE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>values</code>:   A list of R objects to set</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{use_cache}<span class="sc">:</span>   Use the internal cache to avoid reading or writing to the underlying storage <span class="cf">if</span> the data has already been <span class="fu">seen</span> (i.e., we have seen the hash of the object before).</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>list</code></dt>
<dd><p>List all keys stored in a namespace.</p>
<p><em>Usage:</em>
<code>list(namespace = self$default_namespace)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>namespace</code>:   The namespace to list keys within.</p></li>
</ul><p><em>Value</em>:
A sorted character vector (possibly zero-length).</p></dd>

<dt><code>list_hashes</code></dt>
<dd><p>List all hashes stored in the storr</p>
<p><em>Usage:</em>
<code>list_hashes()</code></p>
<p><em>Value</em>:
A sorted character vector (possibly zero-length).</p></dd>

<dt><code>list_namespaces</code></dt>
<dd><p>List all namespaces known to the database</p>
<p><em>Usage:</em>
<code>list_namespaces()</code></p>
<p><em>Value</em>:
A sorted character vector (possibly zero-length).</p></dd>

<dt><code>import</code></dt>
<dd><p>Import R objects from an environment.</p>
<p><em>Usage:</em>
<code>import(src, list = NULL, namespace = self$default_namespace,
      skip_missing = FALSE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>src</code>:   Object to import objects from; can be a list, environment or another storr.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{list}<span class="sc">:</span>   Names of of objects to <span class="fu">import</span> (or <span class="st">`</span><span class="at">NULL</span><span class="st">`</span> to import all objects <span class="cf">in</span> <span class="st">`</span><span class="at">envir</span><span class="st">`</span>.  If given it must be a character vector.  If named, the names of the character vector will be the names of the objects as created <span class="cf">in</span> the storr.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="er">}</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Namespace to get objects from, and to put objects into.  If <span class="st">`</span><span class="at">NULL</span><span class="st">`</span>, all namespaces from <span class="st">`</span><span class="at">src</span><span class="st">`</span> will be imported. If named, then the same rule is followed as <span class="st">`</span><span class="at">list</span><span class="st">`</span>; <span class="st">`</span><span class="at">namespace = c(a = b)</span><span class="st">`</span> will import the contents of namespace <span class="st">`</span><span class="at">b</span><span class="st">`</span> as namespace <span class="st">`</span><span class="at">a</span><span class="st">`</span>.</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{skip_missing}<span class="sc">:</span>   Logical, indicating <span class="cf">if</span> missing <span class="fu">keys</span> (specified <span class="cf">in</span> <span class="st">`</span><span class="at">list</span><span class="st">`</span>) should be skipped over, rather than being treated as an <span class="fu">error</span> (the default).</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>export</code></dt>
<dd><p>Export objects from the storr into something else.</p>
<p><em>Usage:</em>
<code>export(dest, list = NULL, namespace = self$default_namespace,
      skip_missing = FALSE)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>dest</code>:   A target destination to export objects to; can be a list, environment, or another storr.  Use <code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code> to export to a brand new list, or use <code>as.list(object)</code> for a shorthand.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{list}<span class="sc">:</span>   Names of objects to export, with the same rules as <span class="st">`</span><span class="at">list</span><span class="st">`</span> <span class="cf">in</span> <span class="st">`</span><span class="at">$import</span><span class="st">`</span>.</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Namespace to get objects from, and to put objects into.  If <span class="st">`</span><span class="at">NULL</span><span class="st">`</span>, then this will export namespaces from <span class="fu">this</span> (source) storr into the destination; <span class="cf">if</span> there is more than one namespace,this is only possible <span class="cf">if</span> <span class="st">`</span><span class="at">dest</span><span class="st">`</span> is a <span class="fu">storr</span> (otherwise there will be an error).</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>\item{\code{skip_missing}<span class="sc">:</span>   Logical, indicating <span class="cf">if</span> missing <span class="fu">keys</span> (specified <span class="cf">in</span> <span class="st">`</span><span class="at">list</span><span class="st">`</span>) should be skipped over, rather than being treated as an <span class="fu">error</span> (the default).</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul><p><em>Value</em>:
Invisibly, <code>dest</code>, which allows use of <code>e &lt;- st$export(new.env())</code> and <code>x &lt;- st$export(list())</code>.</p></dd>

<dt><code>archive_export</code></dt>
<dd><p>Export objects from the storr into a special "archive" storr, which is an <a href="storr_rds.html">storr_rds</a> with name mangling turned on (which encodes keys with base64 so that they do not violate filesystem naming conventions).</p>
<p><em>Usage:</em>
<code>archive_export(path, names = NULL, namespace = NULL)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>path</code>:   Path to create the storr at; can exist already.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{names}<span class="sc">:</span>   As <span class="cf">for</span> <span class="st">`</span><span class="at">$export</span><span class="st">`</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Namespace to get objects from.  If <span class="st">`</span><span class="at">NULL</span><span class="st">`</span>, then exports all namespaces found <span class="cf">in</span> <span class="fu">this</span> (source) storr.</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>archive_import</code></dt>
<dd><p>Inverse of <code>archive_export</code>; import objects from a storr that was created by <code>archive_export</code>.</p>
<p><em>Usage:</em>
<code>archive_import(path, names = NULL, namespace = NULL)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>path</code>:   Path of the exported storr.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>\item{\code{names}<span class="sc">:</span>   As <span class="cf">for</span> <span class="st">`</span><span class="at">$import</span><span class="st">`</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>}</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>\item{\code{namespace}<span class="sc">:</span>   Namespace to import objects into.  If <span class="st">`</span><span class="at">NULL</span><span class="st">`</span>, then imports all namespaces from the source storr.</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>}</span></code></pre><p></p></div></li>
</ul></dd>

<dt><code>index_export</code></dt>
<dd><p>Generate a data.frame with an index of objects present in a storr. This can be saved (for an rds storr) in lieu of the keys/ directory and re-imported with <code>index_import</code>.  It will provide a more version control friendly export of the data in a storr.</p>
<p><em>Usage:</em>
<code>index_export(namespace = NULL)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>namespace</code>:   Optional character vector of namespaces to export.  The default is to export all namespaces.</p></li>
</ul></dd>

<dt><code>index_import</code></dt>
<dd><p>Import an index.</p>
<p><em>Usage:</em>
<code>index_import(index)</code></p>
<p><em>Arguments:</em></p><ul><li><p><code>index</code>:   Must be a data.frame with columns 'namespace', 'key' and 'hash' (in any order).  It is an error if not all hashes are present in the storr.</p></li>
</ul></dd>


</dl></div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="va">st</span> <span class="op">&lt;-</span> <span class="fu">storr</span><span class="op">(</span><span class="fu"><a href="storr_environment.html">driver_environment</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">## Set "mykey" to hold the mtcars dataset:</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">set</span><span class="op">(</span><span class="st">"mykey"</span>, <span class="va">mtcars</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">## and get the object:</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">get</span><span class="op">(</span><span class="st">"mykey"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</span>
<span class="r-in"><span><span class="co">## List known keys:</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">list</span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "mykey"</span>
<span class="r-in"><span><span class="co">## List hashes</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">list_hashes</span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a63c70e73b58d0823ab3bcbd3b543d6f"</span>
<span class="r-in"><span><span class="co">## List keys in another namespace:</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">list</span><span class="op">(</span><span class="st">"namespace2"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> character(0)</span>
<span class="r-in"><span><span class="co">## We can store things in other namespaces:</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">set</span><span class="op">(</span><span class="st">"x"</span>, <span class="va">mtcars</span>, <span class="st">"namespace2"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">set</span><span class="op">(</span><span class="st">"y"</span>, <span class="va">mtcars</span>, <span class="st">"namespace2"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">list</span><span class="op">(</span><span class="st">"namespace2"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "x" "y"</span>
<span class="r-in"><span><span class="co">## Duplicate data do not cause duplicate storage: despite having three</span></span></span>
<span class="r-in"><span><span class="co">## keys we only have one bit of data:</span></span></span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">list_hashes</span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a63c70e73b58d0823ab3bcbd3b543d6f"</span>
<span class="r-in"><span><span class="va">st</span><span class="op">$</span><span class="fu">del</span><span class="op">(</span><span class="st">"mykey"</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">## Storr objects can be created that have a default namespace that is</span></span></span>
<span class="r-in"><span><span class="co">## not "objects" by using the `default_namespace` argument (this</span></span></span>
<span class="r-in"><span><span class="co">## one also points at the same memory as the first storr).</span></span></span>
<span class="r-in"><span><span class="va">st2</span> <span class="op">&lt;-</span> <span class="fu">storr</span><span class="op">(</span><span class="fu"><a href="storr_environment.html">driver_environment</a></span><span class="op">(</span><span class="va">st</span><span class="op">$</span><span class="va">driver</span><span class="op">$</span><span class="va">envir</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             default_namespace <span class="op">=</span> <span class="st">"namespace2"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">## All functions now use "namespace2" as the default namespace:</span></span></span>
<span class="r-in"><span><span class="va">st2</span><span class="op">$</span><span class="fu">list</span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "x" "y"</span>
<span class="r-in"><span><span class="va">st2</span><span class="op">$</span><span class="fu">del</span><span class="op">(</span><span class="st">"x"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">st2</span><span class="op">$</span><span class="fu">del</span><span class="op">(</span><span class="st">"y"</span><span class="op">)</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Rich FitzJohn.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

